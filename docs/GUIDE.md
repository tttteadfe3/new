# 애플리케이션 리팩토링 및 개발 가이드

## 1. 개요

이 문서는 애플리케이션의 아키텍처, 코딩 표준, 데이터베이스 설계 및 개발 프로세스 전반에 대한 지침을 제공합니다. 모든 개발자는 이 가이드를 숙지하고 준수하여 코드의 일관성과 품질을 유지해야 합니다.

-   **프로젝트 목적**: HR 및 조직 데이터 관리에 중점을 둔 ERP 스타일의 웹 애플리케이션
-   **기술 스택**: PHP, MariaDB, Nginx, Bootstrap CSS

## 2. 아키텍처 (Architecture)

### 2.1. MVC-S (Model-View-Controller-Service) 패턴

애플리케이션은 서비스 계층(Service Layer)이 추가된 MVC 패턴을 따릅니다.

-   **요청 흐름**: `Route` → `Controller` → `Service` → `Repository` → `Database`
-   **Thin Controller 원칙**: 컨트롤러는 HTTP 요청/응답 처리 및 데이터 유효성 검증에 집중하며, 모든 비즈니스 로직은 서비스 계층에 위임합니다. 컨트롤러 내에서 직접 권한을 확인하거나 복잡한 데이터 처리 로직을 포함하지 않습니다.

### 2.2. 디렉토리 구조

-   **컨트롤러**:
    -   페이지 렌더링: `app/Controllers/Web/`
    -   데이터 API: `app/Controllers/Api/`
-   **뷰**:
    -   페이지: `app/Views/pages/` (예: `pages.admin.roles` → `app/Views/pages/admin/roles.php`)
    -   오류 페이지: `app/Views/errors/`
    -   레이아웃 및 공용 컴포넌트: `app/Views/layouts/`
-   **프론트엔드 에셋**:
    -   JavaScript: `public/assets/js/` (하위에 `pages`, `components`, `services` 등으로 구조화)
    -   CSS: `public/assets/css/` (하위에 `pages` 등으로 구조화)
-   **라우팅**:
    -   웹: `routes/web.php`
    -   API: `routes/api.php`

### 2.3. 의존성 주입 (Dependency Injection)

-   DI 컨테이너는 `public/index.php`에서 설정 및 관리됩니다.
-   **주의**: 클래스 생성자 시그니처가 변경될 경우, DI 컨테이너에 등록된 정보도 반드시 함께 수정해야 `too few arguments`와 같은 치명적인 오류를 방지할 수 있습니다.

### 2.4. 인증 및 권한 (Authentication & Authorization)

**역할 분담: 인증(Middleware) vs. 권한(Service Layer)**

이 시스템은 인증과 권한 처리를 명확하게 분리하여 관리합니다.

-   **인증 (Authentication)**: **미들웨어 계층**에서 처리합니다.
    -   `AuthMiddleware`는 사용자가 **로그인했는지 여부**를 확인하는 책임만 가집니다. 라우트(Route) 수준에서 접근을 제어하며, 인증되지 않은 사용자는 로그인 페이지로 리디렉션합니다.

-   **권한 (Authorization)**: **서비스 계층**에서 처리합니다.
    -   로그인한 사용자가 **특정 작업을 수행할 자격이 있는지 여부**(예: '직원 삭제')는 `AuthService`를 통해 각 비즈니스 로직 내에서 직접 확인합니다. 이 방식은 특정 데이터의 맥락(예: '자신이 속한 팀의 직원 정보만 수정 가능')을 고려해야 하는 복잡한 권한 규칙을 유연하게 적용하는 데 유리합니다.

**세부 구현:**

-   **인증**:
    -   `AuthMiddleware`를 사용하여 인증되지 않은 사용자의 라우트 접근을 `/login`으로 리디렉션합니다.
    -   `AuthService->checkAccess()`: 모든 페이지 요청 시 사용자의 현재 상태(활성, 보류, 차단)를 실시간으로 DB에서 확인합니다.
    -   OAuth: Kakao OAuth 로그인은 `AuthController`의 `kakaoCallback` 메소드에서 처리하며, CSRF 보호를 위해 `state` 파라미터를 사용합니다.
-   **권한**:
    -   **2단계 프로세스**: 기능 권한(Permission) 확인 후 데이터 범위(Data Scope)를 적용합니다.
    -   **`AuthService`**: `check(string $permission_key)` 메소드를 통해 사용자의 기능 권한(`resource.action` 형식, 예: `employee.create`)을 중앙에서 관리합니다. 권한은 세션에 캐시되어 성능을 최적화합니다.
    -   **`DataScopeFilter`**: 사용자의 역할과 부서에 따라 접근 가능한 데이터 범위를 결정하고, 이를 SQL `WHERE` 조건으로 생성합니다.
    -   **예외 규칙**:
        -   `employee.manage` 권한을 가진 사용자는 모든 데이터 스코프 필터링을 우회하여 모든 직원 정보를 조회할 수 있습니다.
        -   `무단투기(Littering)`, `대형폐기물(Waste Collection)` 모듈은 현재의 권한 시스템에서 제외되며, 기존의 레거시 권한 로직을 유지합니다.

## 3. 데이터베이스 (Database)

### 3.1. 네이밍 컨벤션

-   **테이블 접두사**: `hr_` (인사 관련), `sys_` (시스템 관련) 접두사를 사용합니다.
-   **예외**: `waste_collections`, `illegal_disposal_cases2` 테이블은 접두사 규칙에서 제외됩니다.

### 3.2. 스키마 및 시딩

-   **스키마**: 모든 테이블 구조는 `database/schema.sql` 파일에 정의됩니다.
-   **시드 데이터**: `database/seeds/` 디렉토리 내의 `.sql` 파일들이 순차적으로 실행됩니다.
-   **자동화**: `scripts/seed.php` 스크립트를 통해 스키마 생성과 시딩을 자동화합니다.
-   **주의사항**:
    -   시드 파일이 `schema.sql`에 존재하지 않는 컬럼을 참조할 경우, 데이터 손실을 방지하기 위해 해당 컬럼을 `schema.sql`에 `NULL`을 허용하는 상태로 다시 추가하는 것을 원칙으로 합니다.
    -   특정 외부 프로세스가 파일명으로 시드 파일을 직접 실행하므로, 불필요해진 시드 파일이라도 삭제하는 대신 빈 파일을 유지하여 'file not found' 오류를 방지해야 합니다. (예: `02_positions.sql`)

### 3.3. 공통 컬럼 설계

-   **감사 (Auditing)**: 생성자(`created_by`), 수정자(`updated_by`) 컬럼에는 `employee_id`를 저장하여 모든 변경 사항을 추적합니다.
-   **소프트 삭제 (Soft Delete)**: `status` 컬럼을 `deleted`로 변경하고 `deleted_at` 타임스탬프를 기록합니다. 데이터를 조회할 때는 반드시 `WHERE deleted_at IS NULL` 조건을 포함해야 합니다.
-   **워크플로우 추적**: 상태 변경을 추적하는 컬럼은 `processed_by`, `processed_at`와 같이 상태 값과 의미가 명확하게 연결되도록 명명합니다.

### 3.4. 쿼리 작성

-   `IN()` 절을 사용할 때는 SQL 인젝션 공격을 방지하기 위해 반드시 파라미터화된 쿼리를 사용해야 합니다.
-   부서와 같이 계층적인 데이터를 조회할 때는 `DepartmentRepository`에서 사용하는 재귀적 CTE(Common Table Expression) 방식을 활용하여 효율성을 높입니다.

### 3.5. 스키마 리팩토링 이력

#### 2025-10-24: 스키마 전체 재작성
- **목표**: 코드베이스와의 일관성 확보 및 가독성 향상
- **주요 변경 사항**:
    - **주석 및 순서 정리**: `database/schema.sql`의 모든 테이블에 대해 필드 주석을 명확하게 수정하고, 필드 순서를 논리적 그룹(ID, 외래 키, 주요 데이터, 타임스탬프 등)으로 재배열했습니다.
    - **필드 추가**: `illegal_disposal_cases2` 테이블에 `rejection_reason`(반려 사유), `mixed`(혼합배출 여부) 필드를 추가하여 모델과의 정합성을 맞췄습니다.
    - **코드 동기화**: `app/Models/Littering.php` 모델의 `$fillable`, `$rules` 배열 및 관련 메소드를 수정하여 새로운 스키마와 일치시켰습니다.
    - **시더 업데이트**: `database/seeds/06_employees.sql`, `07_users.sql` 파일의 `INSERT` 구문을 변경된 필드 순서에 맞게 수정했습니다.
    - **영향**: 이 변경으로 인해 데이터베이스 스키마와 애플리케이션 코드 간의 일관성이 확보되었으며, 향후 유지보수성이 향상되었습니다.

## 4. 코딩 컨벤션 및 모범 사례

### 4.1. PHP (백엔드)

-   **네이밍**: 클래스는 `PascalCase`, 메소드는 `camelCase`를 따릅니다.
-   **문서화**: 모든 주석, docstring 및 문서는 한국어로 작성합니다.
-   `AuthService->logout()`: 로그아웃 처리 시, 세션을 파괴하기 전에 반드시 DB에서 해당 사용자가 존재하는지 확인하여 외래 키 제약 조건 위반 오류를 방지합니다.
-   **데이터 타입**: DB에서 가져온 숫자형 데이터를 JavaScript로 전달할 때는, `intval()` 함수를 사용해 명시적으로 정수형으로 변환하여 타입 불일치로 인한 오류를 예방합니다.

### 4.2. JavaScript (프론트엔드)

-   **네이밍**: 파일명은 `kebab-case.js`를 따릅니다.
-   **라이브러리**: 다중 선택 드롭다운에는 `Choices.js`, 이미지 모달에는 `GLightbox`를 사용합니다.
-   **데이터 전달**: PHP 컨트롤러에서 `View::getInstance()->addJs()`를 통해 `window.pageViewData` 전역 객체로 초기 데이터를 전달하는 '데이터 아일랜드' 패턴을 사용합니다.
-   **UI 권한 제어**: `BasePage` 클래스의 `applyUIPermissions` 함수를 활용합니다. HTML 요소에 `data-permission="resource.action"` 속성을 추가하면, `window.pageViewData.userPermissions`를 기반으로 해당 요소가 자동으로 표시되거나 숨겨집니다.
-   **이벤트 핸들링**: 폼 제출 로직은 개별 버튼의 `click` 이벤트가 아닌, 폼(form)의 `submit` 이벤트에 바인딩하고 `event.preventDefault()`를 호출하는 방식을 사용합니다.

### 4.3. CSS & View

-   **네이밍**: 파일명은 `kebab-case.css`, `kebab-case.php`를 따릅니다.
-   **스타일링**: 인라인 CSS 사용을 지양하고, 페이지별 스타일은 `public/assets/css/pages/` 디렉토리의 개별 CSS 파일로 분리합니다.
-   **이미지 표시**: 이미지를 표시할 때는 16:9 비율의 컨테이너를 사용하고, 이미지 자체는 `object-fit: contain` 스타일을 적용하여 원본 비율을 유지하면서 컨테이너 안에 맞게 표시되도록 합니다.
-   **코드 중복 제거**: 생성(Create)과 수정(Edit) 페이지에서 사용되는 폼은 `_form.php`와 같은 부분 뷰(Partial View)로 분리하여 재사용합니다.

## 5. 개발 프로세스 및 기타

### 5.1. 환경 설정

-   **`.env`**: 데이터베이스 호스트(DB_HOST)는 `localhost` 대신 `127.0.0.1`로 설정하여 소켓 연결 오류를 방지하고 TCP/IP 연결을 강제합니다.
-   **PHP**: `php-mysql` 확장 모듈이 반드시 활성화되어 있어야 합니다.
-   **제약사항**: 개발 환경에 `php`, `mysql` CLI가 없어 일부 자동화 스크립트 실행 및 프론트엔드 검증에 제약이 있을 수 있습니다.

### 5.2. 테스트 및 검증

-   **테스트 스위트**: 현재 프로젝트에는 PHPUnit, Pest 등 자동화된 테스트 프레임워크가 구성되어 있지 않습니다.
-   **프론트엔드 검증**: 환경 문제로 인해 프론트엔드 검증 스크립트 실행이 불가능할 경우, 해당 단계를 건너뛰고 수동으로 검증할 수 있습니다.

### 5.3. 코드 관리

-   **리팩토링**: 라우트 URL을 변경할 경우, 일관성을 위해 관련된 View, JavaScript, CSS 파일명도 함께 변경하는 것을 원칙으로 합니다.
-   **코드 정리**: 사용하지 않는 코드나 파일을 정리할 때는, 먼저 명확한 분석 내용을 제시하고 동의를 얻은 후에 삭제와 같은 파괴적인 작업을 수행합니다.
-   **버그 처리**: 수정 요청이 명시적으로 없었던 버그나 개선점은 즉시 수정하는 대신, `KNOWN_ISSUES.md` 파일이나 관련 코드의 docstring에 상세히 기록하여 추적합니다.

## 6. 에러 처리 (Error Handling)

### 6.1. 예외 처리 전략

-   **기본 원칙**: 예측 가능한 오류(예: 사용자 입력 유효성 검사 실패)는 반환 값을 통해 처리하고, 예측 불가능한 예외(예: 데이터베이스 연결 실패, 외부 API 오류)는 `try-catch` 블록을 사용하여 처리합니다.
-   **`try-catch` 사용 규칙**:
    -   `try` 블록은 가능한 작게 유지하여, 예외가 발생할 수 있는 특정 코드 영역만 감쌉니다.
    -   `catch` 블록에서는 예외를 잡은 후, 단순히 무시하지 말고 반드시 로깅하거나 적절한 사용자 피드백을 제공해야 합니다.
    -   필요 시, 잡은 예외를 더 구체적인 커스텀 예외로 감싸서 다시 던질 수 있습니다.

### 6.2. 커스텀 예외 클래스

-   애플리케이션의 도메인에 맞는 커스텀 예외 클래스를 `app/Exceptions/` 디렉토리 내에 정의하여 사용합니다. (예: `PermissionDeniedException`, `RecordNotFoundException`)
-   커스텀 예외를 사용하면, `catch` 블록에서 예외 유형에 따라 분기 처리가 용이해져 코드의 가독성과 유지보수성이 향상됩니다.

### 6.3. 에러 로깅

-   **로깅 위치**: 모든 예외 정보는 `storage/logs/application.log` 파일에 기록됩니다.
-   **로깅 형식**: 각 로그 항목은 다음 형식을 따르는 JSON 형식으로 기록됩니다.
    ```json
    {
        "timestamp": "YYYY-MM-DD HH:MM:SS",
        "level": "ERROR",
        "message": "Error message",
        "exception": {
            "class": "ExceptionClassName",
            "file": "/path/to/file.php",
            "line": 123
        },
        "context": {
            "user_id": 1,
            "request_uri": "/path/to/request"
        }
    }
    ```
-   **Stack Trace**: 운영 환경(production)에서는 전체 스택 트레이스를 로그에 포함하여 디버깅에 활용하되, 개발 환경(development)에서는 응답에 포함하여 즉시 확인할 수 있습니다.

### 6.4. 사용자에게 에러 메시지 표시

-   **일반 사용자**: 시스템 내부 오류(500번대 에러)가 발생할 경우, 사용자에게는 "오류가 발생했습니다. 관리자에게 문의하세요."와 같은 일반적인 메시지를 표시합니다. 상세한 오류 정보는 절대 노출하지 않습니다.
-   **API 소비자**: API 요청 실패 시에는, 아래의 'API 응답 형식 표준화' 섹션에 정의된 표준 에러 응답 형식을 따릅니다.
-   **유효성 검사 오류**: 사용자의 입력 값에 대한 오류는 각 필드 옆에 명확하고 친절한 메시지를 표시하여 쉽게 수정할 수 있도록 안내합니다.

## 7. API 응답 형식 표준화

모든 API 엔드포인트(` /api/* `)는 일관된 JSON 응답 구조를 반환해야 합니다.

### 7.1. 성공 응답 (2xx)

-   **구조**:
    ```json
    {
        "status": "success",
        "data": {
            // 요청 결과 데이터
        },
        "message": "요청이 성공적으로 처리되었습니다." // 선택 사항
    }
    ```
-   **필드 설명**:
    -   `status`: 항상 `"success"` 값을 가집니다.
    -   `data`: 필수 필드이며, 조회 결과(객체 또는 배열), 생성/수정된 리소스의 ID 등을 포함합니다. 데이터가 없는 경우 `null` 또는 빈 배열 `[]`을 반환합니다.

### 7.2. 실패 응답 (4xx, 5xx)

-   **구조**:
    ```json
    {
        "status": "error",
        "error": {
            "code": "ERROR_CODE",
            "message": "사용자가 이해할 수 있는 에러 메시지입니다."
        },
        "details": { // 개발 환경에서만 포함될 수 있음
            "validation_errors": [
                { "field": "field_name", "message": "유효성 검사 실패 메시지" }
            ],
            "exception": "ExceptionClassName"
        }
    }
    ```
-   **필드 설명**:
    -   `status`: 항상 `"error"` 값을 가집니다.
    -   `error.code`: 에러 유형을 식별할 수 있는 고유한 문자열입니다. (예: `INVALID_INPUT`, `UNAUTHENTICATED`, `SERVER_ERROR`)
    -   `error.message`: 사용자에게 표시될 수 있는 명확한 에러 메시지입니다.
    -   `details`: 선택적 필드로, 유효성 검사 실패 목록이나 예외 클래스 이름과 같은 추가적인 디버깅 정보를 포함할 수 있습니다. **운영 환경(production)에서는 이 필드를 포함하지 않도록 주의해야 합니다.**

## 8. 로깅 (Logging) 정책

### 8.1. 무엇을 로깅할 것인가

-   **에러 및 예외**: 모든 처리되지 않은 예외와 명시적으로 `catch`된 중요한 예외들.
-   **주요 비즈니스 이벤트**: 사용자의 로그인/로그아웃, 주요 데이터 생성/수정/삭제 (예: 직원 정보 변경, 역할 권한 부여), 결제 처리 등 감사 추적이 필요한 이벤트.
-   **외부 API 통신**: 외부 API 요청 및 응답 내용 (단, 민감 정보는 제외).
-   **성능 관련 지표**: 특정 작업의 실행 시간, 느린 쿼리 등 성능 분석에 필요한 정보.

### 8.2. 로그 레벨

-   **DEBUG**: 개발 환경에서만 사용하며, 변수 값이나 특정 코드 경로 실행 여부 등 상세한 디버깅 정보.
-   **INFO**: 사용자 로그인, 데이터 생성 등 정상적인 애플리케이션의 주요 흐름을 나타내는 정보.
-   **WARNING**: 심각한 오류는 아니지만, 잠재적인 문제를 나타낼 수 있는 상황 (예: deprecated된 API 사용, 잘못된 설정 값).
-   **ERROR**: `try-catch`로 처리된 예외, 외부 시스템 연동 실패 등 즉각적인 조치가 필요할 수 있는 심각한 오류.

### 8.3. 로그 파일 관리

-   **위치**: 모든 로그는 `storage/logs/` 디렉토리에 저장됩니다.
    -   일반 애플리케이션 로그: `application.log`
    -   느린 쿼리 로그: `slow_query.log`
-   **로테이션 정책**: 로그 파일은 매일 자정(00:00)을 기준으로 자동으로 로테이션되며, `application-YYYY-MM-DD.log` 형식으로 아카이빙됩니다. 아카이브된 로그 파일은 30일간 보관 후 자동으로 삭제됩니다.

### 8.4. 민감 정보 로깅 금지

-   **엄격한 원칙**: 개인정보(주민등록번호, 주소, 연락처), 금융 정보(계좌번호, 카드번호), 인증 정보(비밀번호, API 키, 토큰)는 **절대로** 로그에 기록해서는 안 됩니다.
-   **필터링**: 로깅 유틸리티를 사용하여, 민감 정보로 의심되는 키(예: `password`, `api_key`, `token`)를 가진 데이터는 자동으로 `[REDACTED]`와 같은 마스킹 처리된 후 로그에 기록되도록 설정합니다.

## 9. 문서 (Documentation)

-   **`README.md`**: 프로젝트의 개요와 주요 정보를 담고 있으며, `GUIDE_PHP.md`, `GUIDE_JS.md` 등 더 상세한 기술 문서로 연결되는 중앙 허브 역할을 합니다.
-   **`AGENTS.md`**: 코딩 규칙 등 개발 에이전트를 위한 추가적인 지침을 포함할 수 있습니다.