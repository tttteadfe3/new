# 데이터베이스 (Database)

> ℹ️ **참고**
> 이 문서는 데이터베이스의 구조와 설계 원칙에 대한 개요를 설명합니다.
> 실제 리포지토리 코드 작성법과 데이터 접근 규칙은 **[신규 개발자 필독 가이드](./DEVELOPER_GUIDE.md)**를 참조하세요.

## 1. 개요 (Overview)

이 문서는 프로젝트의 데이터베이스 스키마, 테이블 관계, 네이밍 컨벤션 및 인덱싱 전략을 설명합니다.

## 2. ERD (Entity-Relationship Diagram)

다음은 이 프로젝트의 핵심 엔티티와 그 관계를 나타내는 텍스트 기반 다이어그램입니다.

```
+---------------+       +---------------+       +---------------+
|    users      |-------|   employees   |-------|  departments  |
| (사용자)      | 1   1 | (직원)        | N   1 | (부서)        |
+---------------+       +---------------+       +---------------+
      |                   |       |                   |
      | 1                 | N     | N                 | N
+---------------+       +---------------+       +---------------+
|     roles     |       |   leaves      |       |   holidays    |
| (권한)        |-------| (휴가)        |       | (휴일)        |
+---------------+ 1     +---------------+       +---------------+
      |
      | N
+---------------+
|    menus      |
| (메뉴)        |
+---------------+

+---------------------------+       +---------------------------+
|      littering            |       |   waste_collections       |
| (무단투기)                |       | (쓰레기 수거)             |
+---------------------------+       +---------------------------+

+---------------------------+       +---------------------------+
|     employee_change_logs  |       |        logs               |
| (직원 정보 변경 이력)     |       | (시스템 활동 로그)        |
+---------------------------+       +---------------------------+
```

### 관계 설명:

-   `users`와 `employees`는 1:1 관계입니다. (하나의 사용자 계정은 하나의 직원 정보에 연결됨)
-   `employees`와 `departments`는 N:1 관계입니다. (여러 직원이 하나의 부서에 속함)
-   `users`와 `roles`는 1:1 관계입니다. (하나의 사용자는 하나의 권한을 가짐)
-   `roles`와 `menus`는 N:N 관계일 가능성이 높습니다 (권한에 따라 접근 가능한 메뉴가 다름 - 중간 테이블 존재 가능성).
-   `employees`와 `leaves`는 1:N 관계입니다. (한 직원은 여러 번의 휴가를 신청할 수 있음)

## 3. 스키마 정보 (Schema Information)

리포지토리 파일들을 기반으로 유추한 주요 테이블과 그 역할은 다음과 같습니다.

-   **`users`**: 시스템에 로그인하는 사용자 계정 정보 (아이디, 비밀번호, 역할 등).
-   **`employees`**: 직원의 상세 정보 (이름, 입사일, 직급, 부서 등).
-   **`departments`**: 회사 조직도에 사용되는 부서 정보.
-   **`positions`**: 직급 정보 (예: 사원, 대리, 과장).
-   **`roles`**: 사용자 권한 그룹 정보 (예: 일반 사용자, 관리자).
-   **`menus`**: 시스템의 메뉴 구조 및 접근 권한 정보.
-   **`leaves`**: 직원의 휴가 신청 및 승인 상태 정보.
-   **`holidays`**: 회사 지정 휴일 또는 공휴일 정보.
-   **`littering`**: 무단투기 민원 관련 데이터.
-   **`waste_collections`**: 쓰레기 수거 관련 데이터.
-   **`logs`**: 시스템의 주요 활동(로그인, 데이터 변경 등)을 기록하는 로그.
-   **`employee_change_logs`**: 직원 정보 변경 이력을 기록하는 로그.

## 4. 네이밍 컨벤션 (Naming Conventions)

-   **테이블**: 소문자 스네이크 케이스(`snake_case`)를 사용하며, 복수형으로 작성합니다. (예: `employees`, `departments`)
-   **컬럼**: 소문자 스네이크 케이스(`snake_case`)를 사용합니다.
-   **Primary Key (PK)**: `id` (auto-incrementing integer)
-   **Foreign Key (FK)**: `[참조하는_테이블_단수형]_id` 형식을 사용합니다. (예: `employees` 테이블의 부서 FK는 `department_id`)

## 5. 인덱싱 전략 (Indexing Strategy)

효율적인 데이터 조회를 위해 다음과 같은 인덱싱 전략을 권장합니다.

### 5.1. 인덱스 생성 원칙

1.  **외래 키(Foreign Key)**: 모든 `*_id` 외래 키 컬럼에는 인덱스를 생성하여 `JOIN` 성능을 최적화합니다.
2.  **자주 사용되는 조회 조건**: `WHERE` 절에서 자주 사용되는 컬럼에는 단일 또는 복합 인덱스를 생성합니다.
    -   예: `employees` 테이블의 `name` 컬럼, `leaves` 테이블의 `status` 컬럼.
3.  **정렬(Sorting)**: `ORDER BY` 절에서 자주 사용되는 컬럼에도 인덱스를 고려하여 정렬 성능을 향상시킵니다.
4.  **카디널리티(Cardinality)**: 고유한 값의 비율(카디널리티)이 높은 컬럼에 인덱스를 생성하는 것이 효율적입니다. (예: `status` 보다는 `employee_id`)

### 5.2. 인덱스 네이밍 컨벤션

-   `idx_[테이블명]_[컬럼명]` 형식을 사용합니다.
    -   예: `employees` 테이블의 `department_id`에 대한 인덱스는 `idx_employees_department_id`
-   복합 인덱스의 경우 컬럼명을 `_`로 연결합니다.
    -   예: `idx_leaves_employee_id_status`

### 5.3. 쿼리 최적화를 위한 인덱스 활용 가이드

-   `EXPLAIN` 명령을 사용하여 쿼리 실행 계획을 분석하고, `type`이 `ALL`(full table scan)인 경우 인덱스 추가를 검토합니다.
-   인덱스를 사용하더라도 데이터의 대부분을 읽어야 하는 쿼리는 성능 향상이 미미할 수 있습니다.
-   `INSERT`, `UPDATE`, `DELETE` 작업이 잦은 테이블의 경우, 과도한 인덱스는 쓰기 성능을 저하시킬 수 있으므로 필수적인 인덱스만 유지합니다.

## 6. 트랜잭션 관리 규칙 (Transaction Management Rules)

-   여러 개의 `INSERT`, `UPDATE`, `DELETE` 문이 하나의 논리적인 작업 단위를 구성할 때는 반드시 트랜잭션을 사용해야 합니다.
-   `Service` 계층에서 트랜잭션을 시작하고 종료하는 것을 원칙으로 하여, 비즈니스 로직의 원자성을 보장합니다.