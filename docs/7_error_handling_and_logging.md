# 7. 오류 처리 및 로깅 분석

## 7.1. 분석

이 애플리케이션의 오류 처리 시스템은 전역 예외 처리기, 라우터 레벨의 오류 핸들러, 그리고 특정 미들웨어에서의 개별 처리라는 다층적인 접근 방식을 사용하고 있습니다.

### 7.1.1. 전역 예외 처리기 (Global Exception Handler)

-   **위치**: `config/config.php`
-   **역할**: `set_exception_handler()` 함수를 사용하여 등록되었으며, 애플리케이션 코드 내에서 `try-catch`로 잡히지 않은 모든 `Throwable`(Error 및 Exception)을 처리하는 최후의 방어선 역할을 합니다.
-   **환경별 동작 분기**:
    -   **`development` (개발) 모드**: `ENVIRONMENT` 상수가 'development'일 때, `display_errors`가 활성화되고 예외의 상세 정보(메시지, 파일 위치, 스택 트레이스)가 HTML 형식으로 화면에 직접 출력됩니다. 이는 개발자가 오류를 신속하게 파악하고 디버깅하는 데 매우 유용합니다.
    -   **`production` (운영) 모드**: `display_errors`가 비활성화되고, 사용자에게는 `errors/error.php?code=500` 페이지로 리디렉션하여 표준화된 오류 페이지만을 보여줍니다. 이는 민감한 시스템 정보를 사용자에게 노출하지 않기 위한 필수적인 보안 조치입니다.
-   **파일 로깅**: `config/config.php` 내에 파일에 오류를 기록하는 `error_log()` 관련 코드가 존재하지만, 현재 **주석 처리(`/* ... */`)** 되어 있어 실제로는 동작하지 않고 있습니다.

### 7.1.2. 라우터 오류 핸들러 (`Router::handleError`)

-   **위치**: `app/Core/Router.php`
-   **역할**: 라우팅 과정에서 발생하는 특정 오류들을 처리합니다.
    -   `404 Not Found`: 요청된 URI에 해당하는 라우트가 없을 때 호출됩니다.
    -   `500 Internal Server Error`: 라우트에 정의된 컨트롤러나 메서드를 찾을 수 없거나, 미들웨어 클래스가 존재하지 않을 때 호출됩니다.
-   **요청 유형별 응답 분기**:
    -   **API 요청** (URI가 `/api/`로 시작): 오류 메시지를 담은 JSON 객체와 적절한 HTTP 상태 코드(404, 500 등)를 반환합니다.
    -   **웹 요청**: `errors/` 디렉토리에서 상태 코드에 맞는 뷰 파일(예: `errors/404.php`)을 찾아 렌더링합니다.

### 7.1.3. 개별 미들웨어의 오류 처리

-   **`PermissionMiddleware`**: 권한이 없는 사용자의 접근(403 Forbidden)을 처리하는 자체 로직을 가지고 있습니다. API 요청에는 JSON 응답을, 웹 요청에는 `ViewDataService`를 통해 메뉴 등 전체 레이아웃을 포함한 403 오류 페이지를 렌더링하여 일관된 사용자 경험을 제공합니다. 이는 `Router::handleError`보다 더 특화되고 사용자 친화적인 오류 처리 방식입니다.

### 7.1.4. 로깅 (Logging)

-   **활동 로그**: `LogRepository`를 통해 사용자의 주요 활동(로그인, 로그아웃 등)을 `sys_activity_logs` 테이블에 기록하는 기능은 잘 구현되어 있습니다.
-   **오류 로그**: 앞서 언급했듯이, 전역 예외 처리기의 파일 로깅 기능이 비활성화되어 있어 시스템 오류에 대한 기록이 현재 이루어지지 않고 있습니다.

## 7.2. 개선 방안 및 제안

현재 오류 처리 구조는 효과적으로 동작하지만, 로깅 기능을 활성화하고 표준화하여 시스템의 안정성과 유지보수성을 크게 향상시킬 수 있습니다.

### 제안 1: 파일 로깅 기능 활성화 및 개선 (가장 중요)

-   **문제점**: `config/config.php`의 오류 로깅 코드가 주석 처리되어 있어, 프로덕션 환경에서 오류가 발생했을 때 원인을 추적할 수 있는 기록이 남지 않습니다.
-   **개선 방안**:
    1.  **주석 제거**: `set_exception_handler` 내의 `error_log()` 관련 코드의 주석을 즉시 제거하여 로깅을 활성화해야 합니다.
    2.  **로그 디렉토리 확인**: 로그 파일이 저장될 `logs/` 디렉토리가 존재하고 웹 서버가 해당 디렉토리에 쓸 수 있는 권한을 가지고 있는지 확인해야 합니다.
    3.  **로그 포맷 개선**: 단순 텍스트 로깅을 넘어, JSON 형식으로 로그를 저장하면 나중에 로그를 파싱하고 분석하기 훨씬 용이합니다.

### 제안 2: PSR-3 호환 로깅 라이브러리 도입 (Monolog)

-   **문제점**: `error_log()` 함수는 간단하지만, 로그 레벨(info, debug, warning, error 등)에 따른 분리, 다양한 핸들러(파일, 데이터베이스, Slack 알림 등)로의 확장 등 고급 로깅 기능을 제공하지 않습니다.
-   **개선 방안**: PHP 생태계의 표준 로깅 인터페이스인 PSR-3를 준수하는 **`Monolog` 라이브러리를 도입**하는 것을 강력히 권장합니다.
    -   `composer require monolog/monolog` 명령어로 쉽게 설치할 수 있습니다.
    -   `Monolog`를 사용하면 다음과 같은 장점을 얻을 수 있습니다.
        -   **다양한 핸들러**: 로그를 파일뿐만 아니라 데이터베이스, 이메일, Slack, Sentry 등 다양한 채널로 쉽게 보낼 수 있습니다.
        -   **로그 레벨 관리**: `info()`, `warning()`, `error()` 등 다양한 레벨로 로그를 기록하여 중요한 오류를 필터링하기 용이합니다.
        -   **컨텍스트 정보 추가**: 로그 메시지에 현재 사용자 ID, 요청 URL, IP 주소 등 풍부한 컨텍스트 정보를 쉽게 추가할 수 있어 디버깅에 매우 유용합니다.
    -   **적용**: 전역 예외 처리기와 `Router::handleError`에서 `error_log()` 대신 `Monolog` 로거를 사용하여 오류를 기록하도록 수정합니다.

### 제안 3: 사용자 정의 예외 클래스 활용

-   **문제점**: 현재 코드에서 오류가 발생하면 주로 일반 `Exception`을 사용하거나, 미들웨어 등에서 직접 응답을 생성하고 `exit()`를 호출합니다.
-   **개선 방안**: 특정 상황에 맞는 **사용자 정의 예외 클래스**를 만들어 사용하는 것을 권장합니다.
    -   예시: `PermissionDeniedException`, `ValidationException`, `ResourceNotFoundException` 등
    -   **장점**:
        -   전역 예외 처리기에서 `catch (PermissionDeniedException $e)`와 같이 예외의 종류에 따라 다른 HTTP 응답(예: 403, 422, 404)을 생성하고 다른 형식으로 로깅할 수 있어 오류 처리 로직을 중앙에서 깔끔하게 관리할 수 있습니다.
        -   코드의 가독성이 향상되고, 오류 발생의 원인을 더 명확하게 표현할 수 있습니다.