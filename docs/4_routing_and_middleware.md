# 4. 라우팅 및 미들웨어 분석

## 4.1. 분석

이 애플리케이션의 라우팅 및 미들웨어 시스템은 `app/Core/Router.php` 클래스를 중심으로 구축되어 있으며, 명확하고 일관된 방식으로 요청을 처리합니다.

### 4.1.1. 라우팅 시스템 (`Router` 클래스)

-   **핵심 컴포넌트**: `app/Core/Router.php`
-   **특징**:
    -   정적(static) 메서드 기반으로 동작하는 커스텀 라우터입니다. `Router::get()`, `Router::post()` 등의 직관적인 메서드를 제공합니다.
    -   **메서드 체이닝(Method Chaining)**을 지원하여, 라우트 정의와 미들웨어 및 이름 설정을 `Router::get(...)->middleware(...)->name(...)`과 같이 간결하고 가독성 높게 연결할 수 있습니다.
    -   **라우트 그룹핑**: `Router::group('/prefix', function() { ... })`을 통해 공통 접두사(prefix)를 가진 라우트들을 묶을 수 있습니다. 이는 `routes/api.php`에서 모든 API 라우트를 `/api` 그룹으로 묶는 데 효과적으로 사용되었습니다.
    -   **동적 파라미터**: `/users/{id}`와 같이 중괄호를 사용하여 URI의 일부를 동적으로 받아 컨트롤러 메서드의 인자로 전달할 수 있습니다.
    -   **이름 기반 라우팅**: `name()` 메서드를 통해 라우트에 고유한 이름을 부여하고, `route()` 헬퍼 함수(내부적으로 `Router::getUriByName()`)를 통해 URI가 변경되더라도 유연하게 링크를 생성할 수 있습니다.

### 4.1.2. 라우트 정의

-   **웹 라우트**: `routes/web.php`에 정의되어 있으며, 주로 HTML 뷰를 반환하는 페이지 라우팅을 담당합니다.
-   **API 라우트**: `routes/api.php`에 정의되어 있으며, `/api` 접두사 그룹 아래에 모든 API 엔드포인트가 RESTful 디자인 원칙에 따라 구성되어 있습니다. (예: `GET /employees`, `POST /employees`, `PUT /employees/{id}`).

### 4.1.3. 미들웨어 시스템

-   **등록**: 미들웨어는 `public/index.php`에서 `Router::addMiddleware('key', Middleware::class)` 형태로 키와 클래스를 매핑하여 등록됩니다. 현재 `auth`와 `permission` 두 개의 미들웨어가 등록되어 있습니다.
-   **적용**: 각 라우트 정의에서 `middleware('key', 'value')` 메서드를 호출하여 미들웨어를 적용합니다. 이 메서드는 체이닝이 가능하여 하나의 라우트에 여러 미들웨어를 순차적으로 적용할 수 있습니다.
    -   `->middleware('auth')`: 사용자가 로그인했는지 확인합니다.
    -   `->middleware('permission', 'permission_key')`: 사용자가 특정 권한을 가졌는지 확인합니다.
-   **실행 흐름**: `Router::dispatch()` 메서드 내에서 매칭된 라우트를 찾은 후, 컨트롤러를 실행하기 전에 해당 라우트에 연결된 모든 미들웨어의 `handle()` 메서드를 순차적으로 실행합니다. 하나라도 실패하면 요청 처리가 중단되고, 미들웨어는 적절한 응답(리디렉션 또는 JSON 오류)을 반환합니다.

## 4.2. 개선 방안 및 제안

현재 라우팅 및 미들웨어 시스템은 직관적이고 효과적입니다. 다음은 시스템의 성능과 확장성을 더욱 향상시키기 위한 제안입니다.

### 제안 1: API 버전 관리 도입

-   **문제점**: 현재 API 라우트는 `/api/...` 형태로 제공됩니다. 향후 API에 큰 변경(breaking changes)이 필요한 경우, 기존 클라이언트와의 호환성을 유지하기 어렵습니다.
-   **개선 방안**: **URI에 버전 번호를 포함**하는 것을 표준적인 모범 사례로 권장합니다. 예를 들어, `Router::group('/api/v1', function() { ... })`와 같이 라우트 그룹을 구성하면, 나중에 새로운 버전의 API(`v2`)를 개발하더라도 기존 `v1`을 사용하는 클라이언트에 영향을 주지 않고 서비스를 유지할 수 있습니다.

### 제안 2: 라우트 캐싱 기능 추가

-   **문제점**: 현재는 모든 요청마다 `web.php`와 `api.php` 파일을 읽고 파싱하여 라우트 테이블을 메모리에 구성합니다. 애플리케이션의 규모가 커지고 라우트의 수가 수백 개 이상으로 늘어나면 이 과정이 약간의 오버헤드가 될 수 있습니다.
-   **개선 방안**: 프로덕션 환경에서는 **라우트 정보를 캐시**하는 기능을 `Router` 클래스에 추가할 수 있습니다.
    1.  개발 중에 `php console route:cache`와 같은 커맨드를 실행합니다.
    2.  이 커맨드는 모든 라우트 파일을 분석하여 최종 라우팅 테이블 배열을 생성하고, 이를 직렬화(serialize)하여 하나의 캐시 파일(예: `storage/cache/routes.php`)에 저장합니다.
    3.  프로덕션 환경의 `index.php`에서는 라우트 파일을 직접 `require`하는 대신, 캐시 파일이 존재하면 이 캐시 파일을 로드하여 즉시 라우트 테이블을 구성합니다.
    -   **효과**: 파일 I/O 및 파싱 과정을 생략하여 요청 처리 속도를 미세하게 향상시킬 수 있습니다.

### 제안 3: API를 위한 Throttling(요청 제한) 미들웨어 추가

-   **문제점**: 현재 API 엔드포인트에는 요청 횟수 제한이 없어, 악의적인 사용자가 단시간에 수많은 요청을 보내 서버에 과부하를 주는 공격(DoS 공격 등)에 취약할 수 있습니다.
-   **개선 방안**: **요청 제한(Rate Limiting 또는 Throttling) 미들웨어**를 새로 구현하여 주요 API 라우트 그룹에 적용하는 것을 강력히 권장합니다.
    -   이 미들웨어는 사용자의 IP 주소나 API 키를 기준으로 분당 또는 시간당 요청 횟수를 제한합니다.
    -   제한을 초과하는 요청에 대해서는 `429 Too Many Requests` HTTP 상태 코드를 반환하여 비정상적인 트래픽으로부터 서버를 보호할 수 있습니다.