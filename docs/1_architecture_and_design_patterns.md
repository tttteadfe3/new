# 1. 아키텍처 및 디자인 패턴 분석

## 1.1. 분석

이 애플리케이션은 특정 프레임워크에 의존하지 않는 커스텀 MVC(Model-View-Controller) 유사 아키텍처를 기반으로 구축되었습니다. 여기에 서비스-리포지토리(Service-Repository) 패턴을 적용하여 코드의 역할을 명확히 분리하고 있습니다.

### 주요 아키텍처 구성 요소

-   **Controller (`app/Controllers`)**: HTTP 요청의 진입점 역할을 합니다. 사용자의 입력을 받아 유효성을 검사하고, 비즈니스 로직 처리를 서비스 계층에 위임한 후, 그 결과를 뷰에 전달합니다. `BaseController`는 뷰 렌더링, 리디렉션, 인증 상태 확인 등 모든 컨트롤러가 공유하는 공통 기능을 제공합니다.
-   **Service (`app/Services`)**: 애플리케이션의 핵심 비즈니스 로직을 담당합니다. 여러 리포지토리를 조합하여 하나의 비즈니스 트랜잭션을 처리하거나, 특정 도메인에 특화된 계산 및 데이터 가공을 수행합니다. 예를 들어, `ViewDataService`는 여러 뷰에서 공통적으로 필요한 메뉴 데이터나 사용자 권한 데이터를 `MenuRepository`를 통해 수집하고 가공하여 제공합니다.
-   **Repository (`app/Repositories`)**: 데이터베이스와의 상호작용을 완전히 책임지는 계층입니다. 모든 SQL 쿼리는 리포지토리 내에 캡슐화되어 있으며, `App\Core\Database`라는 정적 래퍼 클래스를 통해 실행됩니다. 이를 통해 서비스와 컨트롤러는 데이터가 어떻게 저장되고 조회되는지에 대한 구체적인 내용을 알 필요 없이 비즈니스 로직에만 집중할 수 있습니다.
-   **Core (`app/Core`)**: 라우터, 데이터베이스 연결, 뷰 렌더링 등 프레임워크의 핵심 기능을 담당하는 클래스들이 위치합니다.
-   **Middleware (`app/Middleware`)**: 컨트롤러가 실행되기 전후에 공통적으로 처리해야 할 로직(예: 인증, 권한 검사)을 수행합니다.

### 요청 처리 흐름

1.  사용자 요청은 `public/index.php`를 통해 진입합니다.
2.  `Composer` 오토로더, 환경 변수(`.env`), 설정 파일(`config.php`)이 로드됩니다.
3.  `app/Core/Router`가 미들웨어와 라우트(`routes/web.php`, `routes/api.php`)를 등록합니다.
4.  `Router::dispatch()`가 요청된 URI와 HTTP 메서드에 맞는 라우트를 찾습니다.
5.  라우트에 연결된 미들웨어(예: `AuthMiddleware`, `PermissionMiddleware`)가 순차적으로 실행됩니다.
6.  모든 미들웨어를 통과하면 해당 컨트롤러의 메서드가 호출됩니다.
7.  컨트롤러는 비즈니스 로직 처리를 위해 적절한 서비스 메서드를 호출합니다.
8.  서비스는 필요한 데이터를 얻기 위해 하나 이상의 리포지토리 메서드를 호출합니다.
9.  리포지토리는 `Database` 클래스를 통해 SQL 쿼리를 실행하고 결과를 반환합니다.
10. 서비스는 리포지토리에서 받은 데이터를 가공하여 컨트롤러에 반환합니다.
11. 컨트롤러는 서비스에서 받은 데이터를 `View::render()`를 통해 뷰로 전달하고, 최종 HTML을 생성하여 사용자에게 응답합니다.

### 적용된 디자인 패턴

-   **서비스-리포지토리 패턴**: 비즈니스 로직(서비스)과 데이터 접근 로직(리포지토리)을 명확하게 분리하여 코드의 재사용성과 테스트 용이성을 높입니다.
-   **싱글톤 패턴 (유사)**: `Router`, `Database`와 같은 핵심 클래스들이 정적 메서드만으로 구성되어 있어, 사실상 애플리케이션 전역에서 단일 인스턴스처럼 동작합니다.

## 1.2. 개선 방안 및 제안

현재 아키텍처는 역할 분리가 잘 되어 있지만, 코드의 유연성과 유지보수성을 더욱 향상시키기 위해 몇 가지 개선을 제안합니다.

### 제안 1: 일관된 객체 생성 방식 적용

-   **문제점**: 현재 `AuthService`는 인스턴스 기반으로 생성(`new AuthService()`)되는 반면, `ViewDataService`나 `MenuRepository`는 정적(static) 메서드를 통해 호출됩니다. 이러한 비일관성은 코드의 구조를 예측하기 어렵게 만들고, 향후 상태(state)를 가져야 하는 객체로의 전환을 어렵게 합니다.
-   **개선 방안**: **서비스와 리포지토리 계층을 모두 인스턴스 기반으로 표준화**할 것을 권장합니다. 정적 클래스는 전역 상태를 유발할 수 있고 유닛 테스트를 복잡하게 만듭니다. 모든 서비스를 컨트롤러의 생성자에서 `new` 키워드를 통해 초기화하는 방식으로 통일하면 코드의 일관성이 높아집니다.

    ```php
    // 예시: BaseController
    abstract class BaseController
    {
        protected Request $request;
        protected AuthService $authService;
        protected ViewDataService $viewDataService; // 인스턴스 기반으로 변경

        public function __construct()
        {
            $this->request = new Request();
            $this->authService = new AuthService();
            $this->viewDataService = new ViewDataService(); // 생성자에서 주입
        }
    }
    ```

### 제안 2: 의존성 주입(Dependency Injection) 도입 고려

-   **문제점**: 컨트롤러나 서비스가 필요한 객체(의존성)를 내부에서 직접 생성(`new ClassName()`)하고 있습니다. 이는 클래스 간의 결합도(coupling)를 높여 특정 클래스를 교체하거나 유닛 테스트를 작성하기 어렵게 만듭니다. 예를 들어, `AuthService`의 로직을 테스트하려면 실제 데이터베이스 연결이 필요하게 됩니다.
-   **개선 방안**: **의존성 주입 컨테이너**의 도입을 장기적으로 고려해볼 수 있습니다. 사용자께서 의존성 주입을 선호하지 않는다고 하셨으므로, 이는 필수는 아니지만 현대적인 PHP 애플리케이션 설계의 표준적인 접근 방식이 주는 이점을 설명드리고자 합니다. 의존성 주입을 사용하면 외부에서 생성된 객체를 생성자를 통해 주입받게 되므로, 테스트 시에는 실제 객체 대신 가짜(mock) 객체를 쉽게 주입할 수 있습니다. 이는 테스트 격리를 가능하게 하여 코드 품질을 크게 향상시킬 수 있습니다.

    *만약 DI 컨테이너 도입이 부담스럽다면, 최소한 의존성을 생성자에서 주입받는 **생성자 주입(Constructor Injection)** 패턴만이라도 수동으로 적용하는 것을 고려해볼 수 있습니다.*

### 제안 3: ORM(Object-Relational Mapping) 도입 고려

-   **문제점**: 현재 리포지토리에서 순수 SQL 문자열을 직접 작성하고 있습니다. 이는 간단한 쿼리에는 효과적이지만, 복잡한 쿼리가 많아지면 SQL 구문 오류, 보안 취약점(SQL 인젝션), 특정 데이터베이스에 대한 종속성 등의 문제가 발생할 수 있습니다.
-   **개선 방안**: `Eloquent` (Laravel 프레임워크의 ORM)나 `Doctrine`과 같은 **ORM 라이브러리 도입을 고려**해볼 수 있습니다. ORM을 사용하면 SQL 쿼리를 직접 작성하는 대신 객체와 메서드를 통해 데이터베이스와 상호작용할 수 있습니다. 이는 다음과 같은 장점을 제공합니다.
    -   **보안 강화**: SQL 인젝션 공격을 자동으로 방어합니다.
    -   **생산성 향상**: 반복적인 CRUD 코드를 줄이고 비즈니스 로직에 집중할 수 있습니다.
    -   **데이터베이스 독립성**: 다른 종류의 데이터베이스(예: PostgreSQL)로 쉽게 전환할 수 있습니다.
    -   **코드 가독성**: SQL 문자열보다 PHP 코드가 더 읽기 쉽고 유지보수하기 좋습니다.