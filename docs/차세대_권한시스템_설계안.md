# 차세대 유연한 권한 시스템 설계안

## 📋 요구사항 종합

### 1. 기능 권한 (Permission)
- 메뉴/API 접근 제어
- 역할(Role) 기반

### 2. 데이터 권한 (Data Scope)  
- 부서 기반 조회 제어
- 한 관리자가 여러 부서 담당 가능
- **리소스별로 다른 권한** (연차만 공유, 직원 정보는 제한)

### 3. 결재 워크플로우
- 다단계 결재 라인
- 부서/직급 기반 자동 라인 생성
- 문서 유형별 다른 결재 규칙

### 4. 복잡한 조직 구조
- 한 부서에 여러 관리자
- 한 관리자가 여러 부서 담당
- 부서 계층 구조

---

## 🎯 핵심 문제점

현재 구조의 한계:
1. **리소스 타입별 권한 분리가 어려움**
   - `hr_department_view_permissions` 하나로 모든 데이터 제어
   - 연차만 공유하려면 별도 테이블 필요 (확장성 ↓)

2. **권한 계산이 복잡함**
   - `getVisibleDepartmentIdsForCurrentUser()` 하나가 모든 것 결정
   - 리소스별 다른 로직 적용이 어려움

3. **결재 라인이 정적임**
   - approval_lines 테이블로 저장하면 변경 추적 어려움
   - 규칙 변경 시 과거 데이터 영향

---

## 💡 해결 방안: Policy-Based Access Control (PBAC)

### 개념

**"누가(Subject) 어떤 조건에서(Context) 무엇을(Resource) 어떻게(Action) 할 수 있는가"**

```
Policy = (Subject, Resource, Action, Condition) → Allow/Deny
```

### 예시

```json
{
  "subject": "employee:123",
  "resource": "leave:*",
  "action": "view",
  "conditions": {
    "department": ["A팀", "B팀", "C팀"],
    "resource_type": "leave_calendar"
  },
  "effect": "allow"
}
```

---

## 🏗️ 설계 1: Resource-Level Permission System

### 1-1. 테이블 구조

```sql
-- 리소스 타입 정의
CREATE TABLE `permission_resource_types` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,        -- employee, vehicle, leave, supply
  `description` varchar(255),
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
);

-- 액션 정의
CREATE TABLE `permission_actions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,        -- view, create, update, delete, approve
  `description` varchar(255),
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
);

-- 권한 정책 (핵심!)
CREATE TABLE `permission_policies` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `description` text,
  `resource_type_id` int(11) NOT NULL,  -- 어떤 리소스에 대한 정책인가
  `action_id` int(11) NOT NULL,         -- 어떤 액션에 대한 정책인가
  `scope_type` enum('own', 'department', 'managed_departments', 'custom') NOT NULL,
  `scope_config` json,                  -- 추가 설정 (유연성!)
  `is_active` tinyint(1) DEFAULT 1,
  `priority` int(11) DEFAULT 0,         -- 우선순위 (여러 정책 충돌 시)
  PRIMARY KEY (`id`),
  KEY `fk_policy_resource_type` (`resource_type_id`),
  KEY `fk_policy_action` (`action_id`)
);

-- 역할별 정책 할당
CREATE TABLE `role_policies` (
  `role_id` int(11) NOT NULL,
  `policy_id` int(11) NOT NULL,
  PRIMARY KEY (`role_id`, `policy_id`)
);

-- 사용자별 정책 할당 (예외 처리용)
CREATE TABLE `user_policies` (
  `user_id` int(11) NOT NULL,
  `policy_id` int(11) NOT NULL,
  `granted_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `granted_by` int(11),                 -- 누가 부여했는지
  `expires_at` datetime,                -- 만료일 (선택)
  PRIMARY KEY (`user_id`, `policy_id`)
);
```

### 1-2. 정책 예시

#### 정책 1: 본인 데이터만 조회
```sql
INSERT INTO permission_policies 
(name, resource_type_id, action_id, scope_type, scope_config) VALUES
('본인 직원정보 조회', 
 (SELECT id FROM permission_resource_types WHERE name='employee'),
 (SELECT id FROM permission_actions WHERE name='view'),
 'own',
 NULL);
```

#### 정책 2: 관리 부서 직원 조회
```sql
INSERT INTO permission_policies 
(name, resource_type_id, action_id, scope_type, scope_config) VALUES
('관리 부서 직원 조회',
 (SELECT id FROM permission_resource_types WHERE name='employee'),
 (SELECT id FROM permission_actions WHERE name='view'),
 'managed_departments',
 NULL);
```

#### 정책 3: 같은 과 연차 조회 (핵심!)
```sql
INSERT INTO permission_policies 
(name, resource_type_id, action_id, scope_type, scope_config) VALUES
('같은 과 연차 조회',
 (SELECT id FROM permission_resource_types WHERE name='leave'),
 (SELECT id FROM permission_actions WHERE name='view'),
 'custom',
 '{
   "scope": "parent_department_tree",
   "include_children": true
 }');
```

#### 정책 4: 차량은 본인 부서만
```sql
INSERT INTO permission_policies 
(name, resource_type_id, action_id, scope_type, scope_config) VALUES
('본인 부서 차량 조회',
 (SELECT id FROM permission_resource_types WHERE name='vehicle'),
 (SELECT id FROM permission_actions WHERE name='view'),
 'department',
 NULL);
```

### 1-3. PolicyEngine 서비스

```php
// app/Services/PolicyEngine.php
class PolicyEngine {
    
    /**
     * 특정 리소스에 대한 액션 권한 확인
     */
    public function can(
        int $userId, 
        string $resourceType, 
        string $action, 
        ?array $resourceData = null
    ): bool {
        $policies = $this->getUserApplicablePolicies($userId, $resourceType, $action);
        
        foreach ($policies as $policy) {
            if ($this->evaluatePolicy($policy, $userId, $resourceType, $resourceData)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * 조회 가능한 리소스 ID 목록 반환
     */
    public function getScopeIds(
        int $userId,
        string $resourceType,
        string $action = 'view'
    ): ?array {
        $policies = $this->getUserApplicablePolicies($userId, $resourceType, $action);
        $allScopeIds = [];
        
        foreach ($policies as $policy) {
            $scopeIds = $this->calculateScopeIds($policy, $userId);
            $allScopeIds = array_merge($allScopeIds, $scopeIds);
        }
        
        // 전체 조회 권한이 있으면 null 반환
        if ($this->hasGlobalScope($policies)) {
            return null;
        }
        
        return array_unique($allScopeIds);
    }
    
    /**
     * 정책에 따른 스코프 ID 계산
     */
    private function calculateScopeIds(array $policy, int $userId): array {
        $user = $this->getUserWithEmployee($userId);
        
        switch ($policy['scope_type']) {
            case 'own':
                return [$user['employee_id']];
                
            case 'department':
                return [$user['employee']['department_id']];
                
            case 'managed_departments':
                return $this->getManagedDepartmentIds($user['employee_id']);
                
            case 'custom':
                return $this->evaluateCustomScope($policy['scope_config'], $user);
                
            default:
                return [];
        }
    }
    
    /**
     * 커스텀 스코프 평가
     */
    private function evaluateCustomScope(array $config, array $user): array {
        $scope = $config['scope'] ?? '';
        
        switch ($scope) {
            case 'parent_department_tree':
                // 상위 부서의 모든 하위 부서 포함
                $dept = $this->getDepartment($user['employee']['department_id']);
                if ($dept['parent_id']) {
                    return $this->getDepartmentTree($dept['parent_id']);
                }
                return [$user['employee']['department_id']];
                
            case 'peer_departments':
                // 같은 레벨 부서들
                $dept = $this->getDepartment($user['employee']['department_id']);
                return $this->getPeerDepartments($dept['parent_id']);
                
            default:
                return [];
        }
    }
}
```

### 1-4. Repository 적용

```php
// app/Repositories/LeaveRepository.php
class LeaveRepository {
    private PolicyEngine $policyEngine;
    
    public function getAll(array $filters = []): array {
        $user = $this->sessionManager->get('user');
        
        // 리소스 타입별로 다른 정책 적용!
        $scopeDeptIds = $this->policyEngine->getScopeIds(
            $user['id'], 
            'leave',      // 리소스 타입
            'view'        // 액션
        );
        
        $queryParts = [...];
        
        if ($scopeDeptIds === null) {
            // 전체 조회 가능
        } elseif (empty($scopeDeptIds)) {
            $queryParts['where'][] = "1=0";
        } else {
            $inClause = implode(',', array_map('intval', $scopeDeptIds));
            $queryParts['where'][] = "e.department_id IN ($inClause)";
        }
        
        return $this->db->query(...);
    }
}

// app/Repositories/EmployeeRepository.php
class EmployeeRepository {
    public function getAll(array $filters = []): array {
        // 직원 정보는 다른 정책 적용!
        $scopeDeptIds = $this->policyEngine->getScopeIds(
            $user['id'],
            'employee',   // 다른 리소스 타입
            'view'
        );
        
        // 동일한 패턴
    }
}
```

### 1-5. 장점

✅ **리소스별 독립적인 권한 관리**
- 연차는 과 전체 공유
- 직원 정보는 관리 부서만
- 설정만 바꾸면 됨

✅ **극도로 유연함**
- 새로운 scope_type 추가 가능
- scope_config에 JSON으로 무한 확장

✅ **감사(Audit) 용이**
- 누가 언제 어떤 정책을 부여받았는지 추적
- `user_policies.granted_by`, `granted_at`

✅ **시간 제한 권한**
- `expires_at`으로 임시 권한 부여 가능

✅ **우선순위 기반 충돌 해결**
- 여러 정책이 충돌하면 `priority` 높은 것 우선

---

## 🏗️ 설계 2: Attribute-Based Access Control (ABAC)

더 고급 방식 - 속성 기반 권한

### 2-1. 테이블 구조

```sql
-- 정책 규칙 (표현식 기반)
CREATE TABLE `abac_policies` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `resource_type` varchar(50) NOT NULL,
  `action` varchar(50) NOT NULL,
  `rule_expression` text NOT NULL,      -- JSON 표현식
  `effect` enum('allow', 'deny') DEFAULT 'allow',
  `priority` int(11) DEFAULT 0,
  `is_active` tinyint(1) DEFAULT 1,
  PRIMARY KEY (`id`)
);
```

### 2-2. 정책 예시

```json
// 같은 과 연차 조회 정책
{
  "name": "같은 과 연차 조회",
  "resource_type": "leave",
  "action": "view",
  "rule_expression": {
    "and": [
      {
        "subject.employee.department.parent_id": {
          "$eq": { "$ref": "resource.employee.department.parent_id" }
        }
      },
      {
        "subject.employee.department.parent_id": {
          "$ne": null
        }
      }
    ]
  },
  "effect": "allow"
}

// A과장이 A,B팀 관리 정책
{
  "name": "A과장 담당 부서 관리",
  "resource_type": "employee",
  "action": "*",
  "rule_expression": {
    "or": [
      {
        "subject.employee.id": { "$eq": "A과장_ID" },
        "resource.department_id": { "$in": ["A팀_ID", "B팀_ID"] }
      }
    ]
  },
  "effect": "allow"
}
```

### 2-3. 평가 엔진

```php
class ABACEngine {
    public function evaluate(array $policy, array $subject, array $resource): bool {
        $expression = json_decode($policy['rule_expression'], true);
        return $this->evaluateExpression($expression, $subject, $resource);
    }
    
    private function evaluateExpression($expr, $subject, $resource): bool {
        if (isset($expr['and'])) {
            foreach ($expr['and'] as $subExpr) {
                if (!$this->evaluateExpression($subExpr, $subject, $resource)) {
                    return false;
                }
            }
            return true;
        }
        
        if (isset($expr['or'])) {
            foreach ($expr['or'] as $subExpr) {
                if ($this->evaluateExpression($subExpr, $subject, $resource)) {
                    return true;
                }
            }
            return false;
        }
        
        // 실제 비교 수행
        return $this->compareAttributes($expr, $subject, $resource);
    }
    
    private function compareAttributes($expr, $subject, $resource): bool {
        foreach ($expr as $attribute => $condition) {
            $value = $this->resolveAttribute($attribute, $subject, $resource);
            
            foreach ($condition as $operator => $expected) {
                if ($operator === '$eq' && $value !== $expected) return false;
                if ($operator === '$ne' && $value === $expected) return false;
                if ($operator === '$in' && !in_array($value, $expected)) return false;
                // ... 더 많은 연산자
            }
        }
        return true;
    }
}
```

### 2-4. 장점

✅ **극한의 유연성**
- 복잡한 조건도 표현 가능
- 코드 수정 없이 정책만 변경

✅ **동적 규칙**
- 실행 시점에 평가
- 조직 구조 변경에 즉시 대응

⚠️ **단점**
- 성능 부담 (복잡한 표현식 평가)
- 디버깅 어려움
- 과한 설계일 수 있음

---

## 🏗️ 설계 3: Graph-Based Permission (최신 트렌드)

Google Zanzibar 스타일 - 관계 기반 권한

### 3-1. 개념

```
Relation Tuples: (object, relation, subject)

예시:
- (A팀, member, 김팀원)
- (A과, parent, A팀)
- (A과장, manager, A팀)
- (연차캘린더, viewer, A팀)
```

### 3-2. 테이블

```sql
CREATE TABLE `relation_tuples` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `namespace` varchar(50) NOT NULL,      -- department, employee, resource
  `object_id` varchar(100) NOT NULL,     -- A팀, 김팀원, leave_calendar
  `relation` varchar(50) NOT NULL,       -- member, manager, viewer, parent
  `subject_type` varchar(50) NOT NULL,   -- user, department, role
  `subject_id` varchar(100) NOT NULL,
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_tuple` (`namespace`, `object_id`, `relation`, `subject_type`, `subject_id`),
  KEY `idx_check` (`namespace`, `object_id`, `relation`)
);
```

### 3-3. 데이터 예시

```sql
-- 조직 구조
INSERT INTO relation_tuples VALUES
-- A과의 하위 부서들
('department', 'A과', 'parent', 'department', 'A팀'),
('department', 'A과', 'parent', 'department', 'B팀'),
('department', 'A과', 'parent', 'department', 'C팀'),

-- A과장이 A,B팀 관리
('department', 'A팀', 'manager', 'employee', 'A과장'),
('department', 'B팀', 'manager', 'employee', 'A과장'),

-- B과장이 C팀 관리  
('department', 'C팀', 'manager', 'employee', 'B과장'),

-- 팀원들
('department', 'A팀', 'member', 'employee', '김팀원'),
('department', 'B팀', 'member', 'employee', '이팀원'),

-- 연차 캘린더 조회 권한 (핵심!)
('resource', 'leave_calendar', 'viewer', 'department', 'A팀'),
('resource', 'leave_calendar', 'viewer', 'department', 'B팀'),
('resource', 'leave_calendar', 'viewer', 'department', 'C팀');
```

### 3-4. 권한 체크 쿼리

```sql
-- "김팀원이 연차 캘린더를 볼 수 있는가?"
SELECT EXISTS (
  -- 직접 권한
  SELECT 1 FROM relation_tuples 
  WHERE namespace='resource' AND object_id='leave_calendar' 
    AND relation='viewer' AND subject_id='김팀원'
  
  UNION
  
  -- 부서를 통한 간접 권한
  SELECT 1 FROM relation_tuples rt1
  JOIN relation_tuples rt2 
    ON rt2.namespace='department' AND rt2.relation='member' AND rt2.subject_id='김팀원'
  WHERE rt1.namespace='resource' AND rt1.object_id='leave_calendar'
    AND rt1.relation='viewer' AND rt1.subject_id = rt2.object_id
) AS has_permission;
```

### 3-5. 장점

✅ **관계 그래프로 모든 것 표현**
- 조직 구조부터 권한까지 통합

✅ **확장성 극대화**
- 새로운 relation만 추가하면 됨

✅ **Google, Airbnb 등에서 사용**
- 검증된 아키텍처

⚠️ **단점**
- 쿼리 복잡도 높음 (재귀 필요)
- 성능 최적화 필요
- 학습 곡선

---

## 📊 설계 비교

| 항목 | 현재 시스템 | 설계1 (PBAC) | 설계2 (ABAC) | 설계3 (Graph) |
|------|------------|-------------|-------------|--------------|
| **유연성** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **구현 난이도** | ⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **성능** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **유지보수** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **확장성** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **디버깅** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |

---

## 🎯 최종 권장: 설계 1 (Policy-Based) + 점진적 진화

### 이유

1. **현재 시스템과 호환**
   - DataScopeService를 PolicyEngine으로 진화
   - 기존 테이블 활용 가능

2. **적절한 복잡도**
   - 요구사항 충족
   - 과한 설계 아님

3. **단계적 적용**
   - Phase 1: 기본 정책 (own, department, managed_departments)
   - Phase 2: 커스텀 정책 (parent_department_tree 등)
   - Phase 3: 필요시 ABAC 표현식 추가

4. **검증된 패턴**
   - AWS IAM, Google Cloud IAM 유사
   - 많은 사례 존재

---

## 🚀 마이그레이션 전략

### Step 1: 병렬 운영 (1-2주)
```php
class DataScopeService {
    // 기존 메서드 유지
    public function getVisibleDepartmentIdsForCurrentUser() { ... }
    
    // 새 PolicyEngine 점진적 도입
    public function getVisibleDepartmentIdsV2($resourceType) {
        return $this->policyEngine->getScopeIds(..., $resourceType, 'view');
    }
}
```

### Step 2: 선택적 적용 (2-3주)
```php
// 연차만 먼저 새 시스템 적용
class LeaveRepository {
    public function getAll() {
        if (config('use_new_policy_engine')) {
            $scopeIds = $this->dataScopeService->getVisibleDepartmentIdsV2('leave');
        } else {
            $scopeIds = $this->dataScopeService->getVisibleDepartmentIdsForCurrentUser();
        }
    }
}
```

### Step 3: 완전 전환 (1주)
- 모든 Repository를 PolicyEngine으로
- 기존 DataScopeService 제거
- 데이터 마이그레이션

---

## 📋 구현 체크리스트

### Phase 1: 기반 구축 (1주)
- [ ] `permission_resource_types` 테이블
- [ ] `permission_actions` 테이블
- [ ] `permission_policies` 테이블
- [ ] `role_policies` 테이블
- [ ] `PolicyEngine` 기본 골격

### Phase 2: 핵심 기능 (1주)
- [ ] `PolicyEngine::getScopeIds()` 구현
- [ ] `PolicyEngine::can()` 구현
- [ ] 기본 scope_type (own, department, managed_departments)
- [ ] 커스텀 scope (parent_department_tree)

### Phase 3: 적용 (1주)
- [ ] LeaveRepository 적용
- [ ] EmployeeRepository 적용
- [ ] VehicleRepository 적용
- [ ] 단위 테스트

### Phase 4: 고급 기능 (선택)
- [ ] 시간 제한 권한 (`expires_at`)
- [ ] 권한 위임 기능
- [ ] 감사 로그 강화
- [ ] 관리 UI

---

## 💰 예상 투자 시간

| 항목 | 시간 | 비고 |
|------|------|------|
| 설계 확정 | 1일 | 요구사항 정리 + 리뷰 |
| 테이블 생성 | 0.5일 | 마이그레이션 포함 |
| PolicyEngine 개발 | 3일 | 핵심 로직 |
| Repository 적용 | 2일 | 기존 코드 수정 |
| 테스트 | 2일 | 단위 + 통합 테스트 |
| 문서화 | 1일 | 개발자 가이드 |
| **총계** | **9-10일** | 약 2주 |

---

## ✅ 기대 효과

### 단기 (1-3개월)
- ✅ 연차/직원정보/차량 등 리소스별 독립 권한
- ✅ 복잡한 요구사항 설정만으로 대응
- ✅ 코드 수정 없이 정책 변경

### 중기 (3-6개월)
- ✅ 결재 워크플로우 통합
- ✅ 임시 권한, 권한 위임 등 고급 기능
- ✅ 감사 추적 강화

### 장기 (6개월+)
- ✅ 새 모듈 추가 시 표준 패턴 존재
- ✅ 엔터프라이즈급 권한 시스템
- ✅ 다른 시스템과 통합 용이

---

**결론**: Policy-Based 설계로 전환하면 모든 요구사항을 유연하게 처리할 수 있습니다! 🚀
