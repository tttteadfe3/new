# 2. 데이터베이스 상호 작용 및 데이터 모델 분석

## 2.1. 분석

이 애플리케이션의 데이터 관리 구조는 세 가지 주요 구성 요소로 이루어져 있습니다: 데이터베이스 스키마, 중앙 데이터베이스 접근 클래스, 그리고 데이터 모델입니다.

### 2.1.1. 데이터 모델 (Database Schema)

-   **위치**: `database/schema.sql`
-   **구조**:
    -   데이터베이스 스키마는 테이블의 기능에 따라 `sys_`(시스템), `hr_`(인사 관리) 등 명확한 접두사(prefix)를 사용하여 잘 구조화되어 있습니다. 이는 테이블의 역할을 쉽게 파악할 수 있게 돕습니다.
    -   테이블 간의 관계는 외래 키(Foreign Key) 제약 조건을 통해 명시적으로 정의되어 있어 데이터의 무결성을 보장합니다. 예를 들어, `sys_user_roles` 테이블은 `sys_users`와 `sys_roles` 테이블을 연결하는 다대다(many-to-many) 관계를 명확히 보여줍니다.
    -   인덱스(Index)가 적절하게 설정되어 있어 주요 조회 작업의 성능을 최적화하고 있습니다.

### 2.1.2. 데이터베이스 접근 계층 (Database Access Layer)

-   **위치**: `app/Core/Database.php`
-   **특징**:
    -   애플리케이션의 모든 데이터베이스 상호작용은 `Database`라는 단일 클래스를 통해 중앙에서 관리됩니다.
    -   이 클래스는 PDO(PHP Data Objects) 확장 기능을 기반으로 하는 정적(static) 래퍼(wrapper) 클래스입니다.
    -   `getConnection()` 메서드를 통해 데이터베이스 연결을 관리하며, 한 번 생성된 연결은 재사용됩니다(싱글톤 패턴과 유사).
    -   `query()`, `fetchOne()`, `execute()` 등 직관적인 정적 메서드를 제공하여 리포지토리 계층에서 쉽게 데이터베이스 작업을 수행할 수 있도록 지원합니다.
    -   `beginTransaction()`, `commit()`, `rollBack()` 메서드를 제공하여 트랜잭션 관리가 가능합니다. 이는 여러 쿼리를 원자적(atomic)으로 처리해야 할 때 데이터의 일관성을 보장하는 데 필수적입니다.

### 2.1.3. 모델 (Models)

-   **위치**: `app/Models/`
-   **역할**:
    -   이 애플리케이션의 모델은 데이터베이스 테이블과 직접적으로 상호작용하는 로직을 포함하지 않는, **순수한 데이터 객체(Data Transfer Object, DTO)**로서의 역할을 합니다. 이는 데이터베이스 로직이 리포지토리 계층에 완전히 위임된 서비스-리포지토리 패턴의 모범적인 구현입니다.
    -   모든 모델은 `BaseModel.php`를 상속받습니다. `BaseModel`은 다음과 같은 공통 기능을 제공합니다.
        -   **대량 할당(Mass Assignment) 제어**: `$fillable` 속성을 통해 허용된 속성만 모델에 채워지도록 하여 보안을 강화합니다.
        -   **데이터 유효성 검사**: `$rules` 배열에 정의된 규칙에 따라 `validate()` 메서드를 통해 모델의 데이터 유효성을 검사할 수 있습니다. 이는 데이터가 비즈니스 로직에 사용되기 전에 데이터의 정합성을 보장하는 중요한 역할을 합니다.
        -   **속성 접근**: 매직 메서드(`__get`, `__set`)를 통해 객체의 속성에 쉽게 접근하고 값을 할당할 수 있습니다.

### 2.1.4. 데이터 흐름 요약

데이터는 리포지토리 계층에 의해 `Database` 클래스를 통해 조회된 후, 순수한 배열 형태로 서비스 계층에 전달됩니다. 서비스 계층이나 컨트롤러에서는 이 배열 데이터를 사용하여 모델 객체를 생성(`new UserModel($userData)`)하고, 필요에 따라 유효성 검사를 수행하거나 비즈니스 로직을 적용합니다.

## 2.2. 개선 방안 및 제안

현재 데이터 관리 구조는 명확하고 안정적이지만, 장기적인 관점에서 생산성과 유지보수성을 더욱 향상시키기 위한 몇 가지 제안을 드립니다.

### 제안 1: ORM(Object-Relational Mapping) 도입 (재강조)

-   **문제점**: 아키텍처 분석에서 언급했듯이, 리포지토리 내에서 순수 SQL을 사용하는 방식은 복잡한 쿼리가 많아질수록 생산성이 떨어지고 특정 데이터베이스에 종속될 수 있습니다.
-   **개선 방안**: `Eloquent`나 `Doctrine` 같은 ORM을 도입하면 다음과 같은 이점을 얻을 수 있습니다.
    -   **관계(Relationship) 관리의 용이성**: 모델 클래스에 `hasMany`, `belongsTo`와 같은 관계를 정의하여, `sys_users` 객체에서 해당 사용자의 역할(`sys_roles`)을 `$user->roles()`와 같이 매우 직관적으로 가져올 수 있습니다. 이는 복잡한 JOIN 쿼리를 직접 작성할 필요를 없애줍니다.
    -   **타입 안정성 및 자동 완성**: ORM은 조회 결과를 단순 배열이 아닌 **강타입(strongly-typed) 객체**로 반환합니다. 이는 개발 도구(IDE)의 자동 완성 기능을 완벽하게 지원하여 오타로 인한 버그를 줄이고 개발 속도를 크게 향상시킵니다.

### 제안 2: `BaseModel`의 유효성 검사 기능 강화

-   **문제점**: 현재 `BaseModel`의 유효성 검사 기능은 기본적인 규칙(required, string, integer 등)만 지원합니다. 실제 애플리케이션에서는 더 복잡한 검증(예: 특정 테이블에 값이 존재하는지 확인하는 'exists' 규칙)이 필요할 수 있습니다.
-   **개선 방안**: 유효성 검사 로직을 확장하여 데이터베이스와 상호작용하는 규칙을 추가하거나, `illuminate/validation`과 같은 전문적인 유효성 검사 라이브러리를 도입하는 것을 고려해볼 수 있습니다. 이 라이브러리는 Laravel 프레임워크에서 사용되는 강력하고 유연한 검증 컴포넌트로, 기존 코드와 쉽게 통합할 수 있습니다.

### 제안 3: 스키마 파일에 주석(Comment) 추가

-   **문제점**: `schema.sql` 파일의 일부 테이블과 컬럼에는 주석이 있지만, 모든 항목에 일관되게 적용되어 있지는 않습니다.
-   **개선 방안**: 모든 테이블과 중요한 컬럼에 `COMMENT` 구문을 사용하여 한글 설명을 추가하는 것을 권장합니다. 이는 데이터베이스 스키마 자체를 **살아있는 문서(living document)**로 만들어, 새로운 팀원이 합류하거나 오랜 시간이 지난 후에도 데이터의 의미를 빠르고 정확하게 파악하는 데 큰 도움이 됩니다.